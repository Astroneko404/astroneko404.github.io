I"5<p>Krumhansl-Schmuckler algorithm is a key finding algorithm based on pitch class distribution, that calculates the correlation between the pitch class distribution array, and each of the 12 major and 12 minor profile weights.</p>

<p>The full Python code could be found on <a href="https://gist.github.com/Astroneko404/1dcde11576e510e964882bbbafaeb050" target="_blank">my GH Gist</a>.</p>

<h2 id="retrieve-pitch-class-distribution-from-midi">Retrieve Pitch Class Distribution from MIDI</h2>
<p>Let’s use the main theme music of Metro-Cross as an example, and it’s MIDI file could be downloaded <a href="http://www5.plala.or.jp/m5ka1/memo/midiroom/mtrcrsr1.zip" target="_blank">here</a>:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/qh2jOHHsQms" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>(Spoiler: It’s in A minor.)</p>

<p>First we use <a href="https://mido.readthedocs.io/en/latest/index.html" target="_blank">mido</a> to read the MIDI file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from mido import MidiFile
midi_file = MidiFile("[midi]/metro_cross_main.mid")
</code></pre></div></div>

<p>then retrieve the MIDI notes:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def getAllMidiNotes(mid: MidiFile):
    """
    Retrieve midi note information
    :param mid: mido MidiFile
    :return: A list containing all motes with their midi notes number and time
    """
    midi_notes = []
    for track in mid.tracks:
        for msg in track:
            msg_dict = msg.dict()
            if msg_dict["type"] == "note_on" and msg_dict["channel"] != 9:  # Remove the percussion channel
                midi_notes.append([msg_dict["note"], msg_dict["time"]])
    return midi_notes
</code></pre></div></div>

<p>Each <code class="language-plaintext highlighter-rouge">msg_dict</code> looks like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{'type': 'note_off', 'time': 340, 'note': 48, 'velocity': 80, 'channel': 2}
</code></pre></div></div>

<p>Remember that the 10th channel is reserved for percussion, so we need to exclude this channel before extracting all notes.</p>

<p>After retrieving all notes, we calculate the pitch class distribution vector:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def getPitchDuration(note_list):
    """
    Calculate the duration of each pitch class
    :param note_list: The list returned by getAllMidiNotes
    :return: Pitch duration array for Pearson correlation calculation
    """
    pitch_duration = [0 for _ in range(12)]
    for note, length in note_list:
        pitch_duration[note % 12] += length
    return pitch_duration
</code></pre></div></div>

<h2 id="key-profile-weights">Key-Profile Weights</h2>
<p>There are 5 different key-profile weights available in <a href="https://web.mit.edu/music21/doc/moduleReference/moduleAnalysisDiscrete.html#krumhanslschmuckler" target="_blank">music21</a>: SimpleWeights, AardenEssen, BellmanBudge, KrumhanslSchmuckler, and TemperleyKostkaPayne, and their characteristics are explained in <a href="http://extras.humdrum.org/man/keycor/" target="_blank">keycor manpage</a>:</p>
<blockquote>
  <p>Krumhansl-Kessler:</p>

  <p>Strong tendancy to identify the dominant key as the tonic.</p>

  <p>Aarden-Essen:</p>

  <p>Weak tendancy to identify the subdominant key as the tonic.</p>

  <p>Bellman-Budge:</p>

  <p>No particular tendancies for confusions with neighboring keys.</p>

  <p>Temperley-Kostka-Payne:</p>

  <p>Strong tendancy to identify the relative major as the tonic in minor keys. Well-balanced for major keys.</p>

  <p>Simple:</p>

  <p>Performs most consistently with large regions of music, becomes noiser with smaller regions of music.</p>
</blockquote>

<p>Those key-profile weights could be retrieved using music21:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = analysis.discrete.KrumhanslSchmuckler()
len(a.getWeights('major'))
</code></pre></div></div>
<p>However, since they are arrays we could define them as global variables:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KRUMHANSL_SCHMUCKLER_MAJOR = [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88]
KRUMHANSL_SCHMUCKLER_MINOR = [6.33, 2.68, 3.52, 5.38, 2.6, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17]
</code></pre></div></div>

<p>The original major weights are for C major. In order to get the weights for C# major, we simply shift one element to the right, so the array becomes like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2.88, 6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29]
</code></pre></div></div>

<p>Before we use Pearson correlation to calculate the result, let’s define an array that stores the order of different modes so the code part will not be confusing:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MODE_TABLE = [
    "C Major", "C Minor", "C# Major", "C# Minor", "D Major", "D Minor", "D# Major", "D# Minor", "E Major",
    "E Minor", "F Major", "F Minor", "F# Major", "F# Minor", "G Major", "G Minor", "G# Major", "G# Minor",
    "A Major", "A Minor", "A# Major", "A# Minor", "B Major", "B Minor"
]
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def DeterminateKey(midi_file):
    """
    Use weights to perform key determination
    :param midi_file: mido MidiFile
    :return: Pearson correlation result (in list)
    """
    note_length_vector = getPitchDuration(getAllMidiNotes(midi_file))
    corr_res = []

    for idx in range(24):
        shift_idx = 12 - idx // 2
        weight = KRUMHANSL_SCHMUCKLER_MAJOR[shift_idx:] + \
        KRUMHANSL_SCHMUCKLER_MAJOR[:shift_idx] if idx % 2 == 0 else \
        KRUMHANSL_SCHMUCKLER_MINOR[shift_idx:] + KRUMHANSL_SCHMUCKLER_MINOR[:shift_idx]
        corr_res.append(pearsonCorrelation(note_length_vector, weight))
    return corr_res
</code></pre></div></div>

<p>Finally, the index of the maximum value in <code class="language-plaintext highlighter-rouge">corr_res</code> indicates the most likely mode of our MIDI file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>res = DeterminateKey(midi)
print(MODE_TABLE[argmax(res)])
</code></pre></div></div>

<p>However,</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="https://web.mit.edu/music21/doc/moduleReference/moduleAnalysisDiscrete.html" target="_blank">https://web.mit.edu/music21/doc/moduleReference/moduleAnalysisDiscrete.html</a></li>
  <li><a href="http://extras.humdrum.org/man/keycor/" target="_blank">http://extras.humdrum.org/man/keycor/</a></li>
</ul>

:ET